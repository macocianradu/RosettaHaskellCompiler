namespace test.multiple : <"Something">
version "${version.ok}"


type ExchangeRate:
  from int (1..1)
  to int (1..1)
  
type Obs:
  constant number (0..1)
  exchangeRate ExchangeRate (0..1)
  condition: one-of

func Konst:
  inputs:
    constant number (1..1)
  output:
    observable Obs (1..1)
  assign-output observable -> constant:
    constant

func ExchangeRateFunc:
  inputs:
    from int (1..1)
    to   int (1..1)
  output:
    observable Obs (1..1)
  assign-output observable -> exchangeRate -> from:
    from
  assign-output observable -> exchangeRate -> to:
    to

type Contract:
  zero       Contract_Zero       (0..1)
  expired    Contract_Expired    (0..1)
  one        Contract_One        (0..1)
  orContract Contract_Or         (0..1)
  both       Contract_Both       (0..1)
  give       Contract_Give       (0..1)
  thereafter Contract_Thereafter (0..1)
  truncate   Contract_Truncate   (0..1)
  scale      Contract_Scale      (0..1)
  get        Contract_Get        (0..1)
  anytime    Contract_Anytime    (0..1)
  condition: one-of

type Contract_Zero:
   unit int (1..1)
type Contract_Expired:
   unit int (1..1)
type Contract_One:
  currency int (1..1)
type Contract_Or:
  left Contract (1..1)
  right Contract (1..1)
type Contract_Both:
  left Contract (1..1)
  right Contract (1..1)
type Contract_Thereafter:
  earlier Contract (1..1)
  later   Contract (1..1)
type Contract_Give:
  contract Contract (1..1)
type Contract_Truncate:
  expiryDate string     (1..1)
  contract   Contract (1..1)
type Contract_Scale:
  observable Obs (1..1)
  contract Contract (1..1)
type Contract_Get:
  contract Contract (1..1)
type Contract_Anytime:
  contract Contract (1..1)

func MkZero:
  output:
    contract Contract (1..1)
  assign-output contract -> zero -> unit:
    1 // create the zero contract dummy value

func MkExpired:
  output:
    contract Contract (1..1)
  assign-output contract -> expired -> unit:
    1 // create the expired contract dummy value

func MkOne:
  inputs:
    currency int (1..1)
  output:
    contract Contract (1..1)
  assign-output contract -> one -> currency:
    currency

func MkOr:
  inputs:
    left  Contract (1..1)
    right Contract (1..1)
  output:
    contract Contract (1..1)
  assign-output contract -> orContract -> left:
    left
  assign-output contract -> orContract -> right:
    right

func MkBoth:
  inputs:
    left  Contract (1..1)
    right Contract (1..1)
  output:
    contract Contract (1..1)
  assign-output contract -> both -> left:
    left
  assign-output contract -> both -> right:
    right

func MkThereafter:
  inputs:
    earlier  Contract (1..1)
    later Contract (1..1)
  output:
    contract Contract (1..1)
  assign-output contract -> thereafter -> earlier:
    earlier
  assign-output contract -> thereafter -> later:
    later

func MkGive:
  inputs:
    subContract Contract (1..1)
  output:
    contract Contract (1..1)
  assign-output contract -> give -> contract:
    subContract

func MkTruncate:
  inputs:
    truncateTo string      (1..1)
    subContract Contract (1..1)
  output:
    contract Contract (1..1)
  assign-output contract -> truncate -> contract:
    subContract
  assign-output contract -> truncate -> expiryDate:
    truncateTo

func MkScale:
  inputs:
    observable Obs (1..1)
    subContract Contract (1..1)
  output:
    contract Contract (1..1)
  assign-output contract -> scale -> contract:
    subContract
  assign-output contract -> scale -> observable:
    observable

func MkGet:
  inputs:
    subContract Contract (1..1)
  output:
    contract Contract (1..1)
  assign-output contract -> get -> contract:
    subContract

func MkAnytime:
  inputs:
    subContract Contract (1..1)
  output:
    contract Contract (1..1)
  assign-output contract -> anytime -> contract:
    subContract

func MkAnd:
  inputs:
    left Contract (1..1)
    right Contract (1..1)
  output:
    contract Contract (1..1)
  assign-output contract:
    MkThereafter(MkBoth(left,right),MkOr(left,right))

func ZeroCouponBond:
  inputs:
    maturesOn string   (1..1)  <"Date the bond matures on">
    amount number     (1..1)  <"Amount of the bond is worth">
    currency int (1..1)  <"Unit the bond is denoted in">
  output:
    contract Contract (1..1)
  assign-output contract:
    MkGet (MkTruncate(maturesOn, MkScale(Konst(amount),MkOne(currency))))

func Perhaps:
  inputs:
    endDate  string     (1..1)
    contract Contract (1..1)
  output:
    perhaps Contract (1..1)
  assign-output perhaps:
    MkTruncate(endDate,MkOr(contract,MkZero()))

func EuropeanOption:
  inputs:
    endDate  string     (1..1)
    contract Contract (1..1)
  output:
    option Contract (1..1)

  assign-output option:
    MkGet(Perhaps(endDate,contract))